# Chapter 18: FAT16 Filesystem

FAT16 (File Allocation Table, 16-bit) is a simple filesystem used by VOS for persistent storage on the ATA disk.

## FAT16 Structure

### Boot Sector

```c
typedef struct {
    uint8_t  jump[3];           // Jump instruction
    char     oem_name[8];       // OEM identifier
    uint16_t bytes_per_sector;  // Usually 512
    uint8_t  sectors_per_cluster;
    uint16_t reserved_sectors;  // Before first FAT
    uint8_t  num_fats;          // Usually 2
    uint16_t root_entry_count;  // Root directory entries
    uint16_t total_sectors_16;  // 0 if >65535 sectors
    uint8_t  media_type;        // 0xF8 for hard disk
    uint16_t fat_size_16;       // Sectors per FAT
    uint16_t sectors_per_track;
    uint16_t num_heads;
    uint32_t hidden_sectors;
    uint32_t total_sectors_32;
    uint8_t  drive_number;
    uint8_t  reserved;
    uint8_t  boot_signature;    // 0x29
    uint32_t volume_id;
    char     volume_label[11];
    char     fs_type[8];        // "FAT16   "
} __attribute__((packed)) fat16_boot_t;
```

### Directory Entry

```c
typedef struct {
    char     name[8];           // Filename (space-padded)
    char     ext[3];            // Extension (space-padded)
    uint8_t  attributes;        // File attributes
    uint8_t  reserved;
    uint8_t  create_time_tenth;
    uint16_t create_time;
    uint16_t create_date;
    uint16_t access_date;
    uint16_t first_cluster_high; // Always 0 for FAT16
    uint16_t modify_time;
    uint16_t modify_date;
    uint16_t first_cluster;     // Starting cluster
    uint32_t file_size;
} __attribute__((packed)) fat16_entry_t;
```

### File Attributes

```c
#define ATTR_READ_ONLY  0x01
#define ATTR_HIDDEN     0x02
#define ATTR_SYSTEM     0x04
#define ATTR_VOLUME_ID  0x08
#define ATTR_DIRECTORY  0x10
#define ATTR_ARCHIVE    0x20
#define ATTR_LONG_NAME  (ATTR_READ_ONLY | ATTR_HIDDEN | \
                         ATTR_SYSTEM | ATTR_VOLUME_ID)
```

## Disk Layout

```
+------------------+
| Boot Sector      | Sector 0
+------------------+
| Reserved Sectors |
+------------------+
| FAT 1            |
+------------------+
| FAT 2 (copy)     |
+------------------+
| Root Directory   | Fixed size
+------------------+
| Data Clusters    | Cluster 2 starts here
+------------------+
```

## FAT16 Mounting

```c
typedef struct {
    uint32_t partition_start;   // LBA of partition start
    uint32_t fat_start;         // LBA of first FAT
    uint32_t root_start;        // LBA of root directory
    uint32_t data_start;        // LBA of first data cluster
    uint32_t sectors_per_cluster;
    uint32_t bytes_per_cluster;
    uint32_t root_entries;
    uint32_t total_clusters;
    uint16_t *fat;              // Cached FAT
} fat16_fs_t;

int fat16_mount(block_device_t *dev, uint32_t partition_lba) {
    fat16_fs_t *fs = kcalloc(1, sizeof(fat16_fs_t));

    // Read boot sector
    uint8_t sector[512];
    dev->read(partition_lba, 1, sector);
    fat16_boot_t *boot = (fat16_boot_t *)sector;

    // Validate
    if (memcmp(boot->fs_type, "FAT16", 5) != 0) {
        kfree(fs);
        return -EINVAL;
    }

    // Calculate layout
    fs->partition_start = partition_lba;
    fs->sectors_per_cluster = boot->sectors_per_cluster;
    fs->bytes_per_cluster = boot->sectors_per_cluster * 512;
    fs->root_entries = boot->root_entry_count;

    fs->fat_start = partition_lba + boot->reserved_sectors;
    uint32_t fat_sectors = boot->fat_size_16 * boot->num_fats;
    fs->root_start = fs->fat_start + fat_sectors;
    uint32_t root_sectors = (boot->root_entry_count * 32 + 511) / 512;
    fs->data_start = fs->root_start + root_sectors;

    // Cache FAT
    uint32_t fat_size = boot->fat_size_16 * 512;
    fs->fat = kmalloc(fat_size);
    for (uint32_t i = 0; i < boot->fat_size_16; i++) {
        dev->read(fs->fat_start + i, 1,
                  (uint8_t *)fs->fat + i * 512);
    }

    // Create VFS node
    vfs_node_t *root = vfs_create_node("disk", VFS_DIRECTORY);
    root->ops = &fat16_ops;
    root->fs_data = fs;

    vfs_mount("/disk", root);

    return 0;
}
```

## Cluster Operations

### Cluster to LBA

```c
static uint32_t cluster_to_lba(fat16_fs_t *fs, uint32_t cluster) {
    return fs->data_start + (cluster - 2) * fs->sectors_per_cluster;
}
```

### Read Cluster

```c
static void read_cluster(fat16_fs_t *fs, uint32_t cluster, void *buffer) {
    uint32_t lba = cluster_to_lba(fs, cluster);
    for (uint32_t i = 0; i < fs->sectors_per_cluster; i++) {
        ata_read(lba + i, 1, (uint8_t *)buffer + i * 512);
    }
}
```

### Get Next Cluster

```c
static uint16_t next_cluster(fat16_fs_t *fs, uint16_t cluster) {
    return fs->fat[cluster];
}

#define FAT16_FREE      0x0000
#define FAT16_RESERVED  0x0001
#define FAT16_BAD       0xFFF7
#define FAT16_END       0xFFF8  // 0xFFF8-0xFFFF = end of chain
```

### Allocate Cluster

```c
static uint16_t alloc_cluster(fat16_fs_t *fs) {
    for (uint16_t i = 2; i < fs->total_clusters; i++) {
        if (fs->fat[i] == FAT16_FREE) {
            fs->fat[i] = FAT16_END;
            fat16_write_fat(fs);
            return i;
        }
    }
    return 0;  // No free clusters
}
```

## Reading Files

```c
static int32_t fat16_read(vfs_node_t *node, uint32_t offset,
                          uint32_t size, void *buffer) {
    fat16_fs_t *fs = get_fs(node);
    fat16_file_t *file = (fat16_file_t *)node->fs_data;

    if (offset >= file->size) return 0;
    if (offset + size > file->size) {
        size = file->size - offset;
    }

    uint32_t bytes_read = 0;
    uint8_t *cluster_buf = kmalloc(fs->bytes_per_cluster);

    // Find starting cluster
    uint16_t cluster = file->first_cluster;
    uint32_t cluster_offset = offset / fs->bytes_per_cluster;

    for (uint32_t i = 0; i < cluster_offset && cluster < FAT16_END; i++) {
        cluster = next_cluster(fs, cluster);
    }

    // Read data
    uint32_t pos_in_cluster = offset % fs->bytes_per_cluster;

    while (bytes_read < size && cluster >= 2 && cluster < FAT16_END) {
        read_cluster(fs, cluster, cluster_buf);

        uint32_t to_copy = fs->bytes_per_cluster - pos_in_cluster;
        if (to_copy > size - bytes_read) {
            to_copy = size - bytes_read;
        }

        memcpy((uint8_t *)buffer + bytes_read,
               cluster_buf + pos_in_cluster, to_copy);

        bytes_read += to_copy;
        pos_in_cluster = 0;
        cluster = next_cluster(fs, cluster);
    }

    kfree(cluster_buf);
    return bytes_read;
}
```

## Writing Files

```c
static int32_t fat16_write(vfs_node_t *node, uint32_t offset,
                           uint32_t size, const void *buffer) {
    fat16_fs_t *fs = get_fs(node);
    fat16_file_t *file = (fat16_file_t *)node->fs_data;

    uint32_t end = offset + size;
    uint32_t clusters_needed = (end + fs->bytes_per_cluster - 1) /
                               fs->bytes_per_cluster;

    // Extend cluster chain if needed
    uint16_t cluster = file->first_cluster;
    if (cluster < 2) {
        cluster = alloc_cluster(fs);
        file->first_cluster = cluster;
    }

    // ... extend chain to clusters_needed ...

    // Write data (similar to read, but write_cluster instead)
    // ...

    // Update file size
    if (end > file->size) {
        file->size = end;
        node->length = end;
    }

    // Update directory entry
    fat16_update_entry(fs, file);

    return size;
}
```

## Directory Operations

### Read Directory

```c
static int32_t fat16_readdir(vfs_node_t *node, uint32_t index,
                             struct dirent *entry) {
    fat16_fs_t *fs = get_fs(node);
    fat16_entry_t entries[16];  // 16 entries per sector

    uint32_t entries_per_cluster = fs->bytes_per_cluster / 32;
    uint32_t cluster = get_first_cluster(node);
    uint32_t current_index = 0;

    // Handle root directory specially
    bool is_root = (cluster == 0);

    while (true) {
        uint32_t lba;
        uint32_t count;

        if (is_root) {
            lba = fs->root_start;
            count = (fs->root_entries * 32 + 511) / 512;
        } else {
            if (cluster < 2 || cluster >= FAT16_END) break;
            lba = cluster_to_lba(fs, cluster);
            count = fs->sectors_per_cluster;
        }

        for (uint32_t s = 0; s < count; s++) {
            ata_read(lba + s, 1, entries);

            for (int i = 0; i < 16; i++) {
                fat16_entry_t *e = &entries[i];

                if (e->name[0] == 0x00) return -1;  // End
                if (e->name[0] == 0xE5) continue;   // Deleted
                if (e->attributes & ATTR_VOLUME_ID) continue;
                if (e->attributes & ATTR_LONG_NAME) continue;

                if (current_index == index) {
                    // Found it
                    fat16_name_to_string(e, entry->d_name);
                    entry->d_type = (e->attributes & ATTR_DIRECTORY) ?
                                    DT_DIR : DT_REG;
                    entry->d_ino = e->first_cluster;
                    return 0;
                }
                current_index++;
            }
        }

        if (is_root) break;
        cluster = next_cluster(fs, cluster);
    }

    return -1;
}
```

### 8.3 Filename Conversion

```c
static void fat16_name_to_string(fat16_entry_t *entry, char *str) {
    int i = 0;

    // Copy name (trim trailing spaces)
    for (int j = 0; j < 8 && entry->name[j] != ' '; j++) {
        str[i++] = tolower(entry->name[j]);
    }

    // Add extension if present
    if (entry->ext[0] != ' ') {
        str[i++] = '.';
        for (int j = 0; j < 3 && entry->ext[j] != ' '; j++) {
            str[i++] = tolower(entry->ext[j]);
        }
    }

    str[i] = '\0';
}

static void string_to_fat16_name(const char *str, char *name, char *ext) {
    memset(name, ' ', 8);
    memset(ext, ' ', 3);

    const char *dot = strchr(str, '.');

    int len = dot ? (dot - str) : strlen(str);
    if (len > 8) len = 8;
    for (int i = 0; i < len; i++) {
        name[i] = toupper(str[i]);
    }

    if (dot) {
        int elen = strlen(dot + 1);
        if (elen > 3) elen = 3;
        for (int i = 0; i < elen; i++) {
            ext[i] = toupper(dot[1 + i]);
        }
    }
}
```

## Long Filename Support

FAT16 supports long filenames (LFN) through special directory entries:

```c
typedef struct {
    uint8_t  sequence;      // Sequence number
    uint16_t name1[5];      // Characters 1-5
    uint8_t  attributes;    // Always 0x0F
    uint8_t  type;
    uint8_t  checksum;
    uint16_t name2[6];      // Characters 6-11
    uint16_t zero;
    uint16_t name3[2];      // Characters 12-13
} __attribute__((packed)) fat16_lfn_entry_t;
```

VOS supports reading LFNs but typically writes 8.3 names for simplicity.

## Limitations

- Maximum partition size: ~2-4 GB
- Maximum file size: 2 GB (4 GB theoretical)
- 8.3 filenames (LFN reading supported)
- Case insensitive
- No permissions/ownership

## Summary

FAT16 provides:

1. **Simple structure** easy to implement
2. **Persistent storage** on disk
3. **Directory hierarchy** support
4. **Compatible format** readable by other OSes
5. **Sufficient capacity** for VOS needs

---

*Previous: [Chapter 17: RAM Filesystem](17_ramfs.md)*
*Next: [Chapter 19: Tasking and Scheduling](19_tasking.md)*
